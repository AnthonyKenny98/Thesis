% @Author: AnthonyKenny98
% @Date:   2020-02-22 15:53:59
% @Last Modified by:   AnthonyKenny98
% @Last Modified time: 2020-02-27 15:46:33

\ac{RRT} is an algorithm designed to efficiently search, and thus plan a path through, a high-complexity environment by randomly sampling points and building a tree. The algorithm randomly samples points, draws an edge from the nearest currently existing node in the tree, to grow the tree in the space. It is inherently biased to grow towards large unsearched areas of the problem. RRT was developed by S. LaVelle\cite{LaValle1998} and J. Kuffner\cite{LaValle2001}. It is used in autonomous robotic motion planning problems such as autonomous drones, the focus of this thesis.

\subsection{Algorithm}

    The pseudocode for \ac{RRT} can be seen in Algorithm \ref{algorithm:rrt}
    \input{chapters/chapter2/algorithms/rrt_alg}

    \todo[inline]{Explanation of RRT and how it relates to configuration}
    Algorithm \ref{algorithm:rrt} can be visually represented in Figure \ref{fig:rrt-step-by-step}. Consider a \ac{2D} robot operating in a \ac{2D} workspace. A Graph $G$ is initialized containing an initial configuration, $q_{init}$, with constraints on the number of nodes that the graph can hold, $K$, and the maximum distance between two nodes, $\Delta q$. This is shown in Subfigure \ref{subfig:rrt-step-by-step-A}. A random configuration for the robot, $q_{rand}$ is generated (\ref{subfig:rrt-step-by-step-B}). The nearest existing configuration in $G$, $q_{near}$, is found. (In the first iteration, $q_{near} = q_{init}$, shown in Subfigure \ref{subfig:rrt-step-by-step-C}). The distance between $q_{near}$ and $q_{rand}$ is calculated. If this distance is less than $\Delta q$, $q_{new} = q_{rand}$. If not, $q_{new}$ is selected, typically by moving by $\Delta q$ from $q_{near}$ towards $q_{rand}$ (\ref{subfig:rrt-step-by-step-C}). $q_{new}$ is then added to $G$. This is repeated for $K$ configurations.

    \input{chapters/chapter2/figures/rrt-step-by-step}

    \newpage % Delete

    The RRT Algorithm with Collision Detection can be seen in Algorthim \ref{algorithm:rrt_point}.
    \input{chapters/chapter2/algorithms/rrt_alg_point}

\subsection{Implementation}
    
    The project required an implementation of RRT that fulfilled the following criteria:

    \begin{enumerate}
        \item Implemented in C
        \item Modelled a drone as a point in a 3D space
        \item Was implemented in such a way that made it suitable for CPU execution analysis.
    \end{enumerate}

    The original intention was to find an existing implementation of RRT that could fulfill these requirements. Most open source implementations found online were in Python, and all those implemented in C were unsuitable\cite{RoboJackets2019}\cite{Planning2019}\cite{Sourishg2017}\cite{Vss2sn2019}, as they had extraneous \ac{GUI}s, reliance on external \ac{API}s, and other features that would distort analysis of algorithmic hotspots.

    As a result, it was neccesary to build a C implementation of RRT from the ground up. It can be found in this project's GitHub repository. It follows Algorithm \ref{algorithm:rrt} closely. For monitoring correctness, I build in an optional \ac{GUI} that shows the tree, starting node, and obstacles. 

    \subsubsection{Implementation in 2D}
    The first step was to implement RRT with a 2-Dimensional workspace. \todo[inline]{More detail}
    \input{chapters/chapter2/figures/rrtImplementation2D.tex}

    \subsubsection{Implementation in 3D}
    \todo[inline]{Describe implementation in 3D}
    \input{chapters/chapter2/figures/rrtImplementation3D.tex}

    


\subsection{Performance Analysis}
    To restate, the aim of this thesis is to design a computer processor with reduced execution time of motion planning algorithms, such as \ac{RRT}. As such, it is important to understand the elements of the algorithm that have the highest percentage of CPU execution time. To determine this, it was necessary to implement my own, naive but typical, \ac{RRT} in C. This program could then be compiled and analysed using a software performance profiling tool. With this, I could design experiments to determine the critical RRT functions (those occupying a majority of CPU time) and see how this varies given different paramaters.
    \todo[inline]{Introduction to purpose of analysis and methods of doing so. Something better than the above}

    \subsubsection{VTune Amplifier Analysis}
        VTune Amplifier performance profiler is an application for software performance analysis. It provides functionality to examine hotspots for CPU execution time through a top down analysis, shown below in Figure \ref{figure:VTuneTopDown}. As can be seen from the figure, the top down analysis tool shows the percentage of CPU time taken up by each function. I used this tool to profile the algorithm's performance as I changed certain parameters.
        \todo[inline]{Rewrite the above}
        \input{chapters/chapter2/figures/VTuneTopDown.tex}

    \subsubsection{Internal Timing Analysis}

    \subsubsection{Comparison}