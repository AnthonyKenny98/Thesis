% @Author: AnthonyKenny98
% @Date:   2020-02-28 15:02:19
% @Last Modified by:   AnthonyKenny98
% @Last Modified time: 2020-04-05 22:30:46

Having implemented a functioning version of \gls{RRT} that adhered to the specifications set out in Table \ref{table:RRT_Tech_Specs_Abbrev}, analysis of its computational profile could begin. The purpose of this analysis is to identify the biggest bottleneck of \gls{RRT} and therefore the best opportunity for hardware acceleration.{}

\subsection{Measuring Performance}

    \subsubsection*{VTune Profiler}
    \label{subsubsection:vtune}
        VTune Profiler performance profiler is an application for software performance analysis. It provides functionality to examine hot-spots for CPU execution time through a top down analysis, shown below in Figure \ref{figure:VTuneTopDown}. As can be seen from the figure, the top down analysis tool shows the percentage of CPU time taken up by each function. I used this tool to profile the algorithm's performance as I changed certain parameters.
        \todo[inline]{Rewrite the above}
        \input{chapters/chapter2/figures/VTuneTopDown.tex}

    \subsubsection*{Internal Timing}
        The limitation of VTune Profiler is that it can only profile software running on Intel processors, which implement the x86 \gls{ISA}. As such, when the time comes to analyse performance of the software running on a RISC-V processor, another method will be required. A simple and effective way of measuring execution performance is to insert timing functionality into the software itself. \\

        \todo[inline]{Provide or link to appendix of explanation of internal timing}

    \subsubsection*{Comparison}
        Before proceeding to use either of these methods to profile the software implementation of \gls{RRT}, it was important to verify that the two methods yielded similar results for the same program. Table \ref{table:timing_calibration} summarizes the results of analysis of a simple C executable. The program calls 5 functions, $\{A, B, C, D, E\}$, each a simple iteration in which a integer is incremented. Since the Internal Timing method returned similar results to the (trusted) VTune Profiler, it was considered to be a reliable method. While it was encouraging to see both methods returned similar results for absolute execution time, the more important metric was the similarity in percentage of total execution time.

        \todo[inline]{Chi Squared Test}

        \input{chapters/chapter2/tables/timing_calibration}

\subsection{Experimental Methodology}
    \todo[inline]{Outline of method of analysis.}


    \subsubsection{Optimal Parameters}
        Extensive testing was undertaken to determine the 


    \subsubsection*{Experimental Design}
        In profiling \gls{RRT} in software, the goal was to find the critical task across different values of $K$ and sizes of \gls{configuration} space. Multiple tests were run, varying these two constraints, to find this critical function. The results of this analysis can be found in Section \ref{section:rrt_analysis_results}.

\subsection{Results}
\label{section:rrt_analysis_results}
    Figure \ref{fig:rrt_profiling} shows the profile of functions within \gls{RRT}, for $100 \leq K \leq 10000$, and cubic \gls{configuration} spaces with dimensions $\{4, 8, 16, 32\}$. Each subfigure shows a similar profile, with the \% of CPU Execution Time taken by findNearestNode increasing with $K$. This is to be expected. \todo{Explanation of time complexity}However, it is also seen that edgeCollisions increases with larger \gls{configuration} spaces, taking up the overwhelming majority of execution time for a 32x32x32 \gls{configuration} space.
    
    \newpage
    \input{chapters/chapter2/figures/rrtprofiling}

    Furthermore, the computational load of findNearestNode can be reduced through a variety of software optimizations. A simple one used here to demonstrate that fact is storing nodes in seperate ``buckets,'' sorted by their $x$ value. By using only two buckets, the execution time of findNearestNode fell drastically. Figure \ref{subfig:32x32x32rrt2} shows edge collision detection accounting for over 95\% of execution time for $100 \leq K \leq 10000$. This is consistent with the profiling results of \gls{RRT} in prior work\cite{Bialkowski2011}.

    \subsubsection*{Conclusion}
        From the above data, it was identified that, as prior work suggested, edge collision detection shows the greatest promise for potential speedup through specialized hardware. The next chapter details the process of designing and building this hardware.
        \todo[inline]{Add simulations to determine correct K}

    \input{chapters/chapter2/figures/rrt_profiling_2}
